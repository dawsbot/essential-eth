import fs from 'fs';
import path from 'path';
import z from 'zod';
import importantChainIds from './important-chain-ids.json';

const outputFilePath = path.join(
  __dirname,
  '..',
  '..',
  'src',
  'providers',
  'utils',
  'chains-info.ts',
);
const chainsSchema = z.array(
  z.object({
    shortName: z.string().min(1),
    chainId: z.number().int().min(1),
    ens: z.union([
      z.object({
        registry: z
          .string({
            invalid_type_error: 'Should have type string for ENS "registry"',
          })
          .startsWith('0x'),
      }),
      z.undefined(),
    ]),
  }),
);
(async () => {
  const toReturn: Record<string, ReadonlyArray<string>> = {};
  await fetch('https://chainid.network/chains.json')
    .then((res) => res.json())
    .then(chainsSchema.parse)
    .then((data) => {
      data.forEach((networkInfo) => {
        const { shortName, chainId } = networkInfo;
        if (!importantChainIds.includes(chainId)) return;
        const writeableInfo = [shortName];

        const registry = networkInfo.ens?.registry;
        if (registry) {
          writeableInfo.push(registry);
        }
        toReturn[chainId] = writeableInfo;
      });
    });

  const MATCHING_CHAINS_MIN_LENGTH = 17;
  const matchingChainsLength = Object.keys(toReturn).length;
  z.number()
    .min(
      MATCHING_CHAINS_MIN_LENGTH,
      `Matching chains should be atleast ${MATCHING_CHAINS_MIN_LENGTH} long, but got ${matchingChainsLength}`,
    )
    .parse(matchingChainsLength);
  fs.writeFileSync(
    outputFilePath,
    `// autogenerated in "fetch-chains-info.ts"\n// Do not edit directly\nexport default ${JSON.stringify(
      toReturn,
      null,
      2,
    )}`,
  );
})();
